{"ast":null,"code":"'use strict';\n\nconst CastError = require('../../error/cast');\nconst MongooseError = require('../../error/mongooseError');\nconst SchemaString = require('../../schema/string');\nconst StrictModeError = require('../../error/strict');\nconst ValidationError = require('../../error/validation');\nconst castNumber = require('../../cast/number');\nconst cast = require('../../cast');\nconst getConstructorName = require('../getConstructorName');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst getEmbeddedDiscriminatorPath = require('./getEmbeddedDiscriminatorPath');\nconst handleImmutable = require('./handleImmutable');\nconst moveImmutableProperties = require('../update/moveImmutableProperties');\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst setDottedPath = require('../path/setDottedPath');\nconst utils = require('../../utils');\nconst {\n  internalToObjectOptions\n} = require('../../options');\nconst mongodbUpdateOperators = new Set(['$currentDate', '$inc', '$min', '$max', '$mul', '$rename', '$set', '$setOnInsert', '$unset', '$addToSet', '$pop', '$pull', '$push', '$pullAll', '$bit']);\n\n/**\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict] defaults to true\n * @param {Query} context passed to setters\n * @return {Boolean} true iff the update is non-empty\n * @api private\n */\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\n  if (obj == null) {\n    return undefined;\n  }\n  options = options || {};\n  // Update pipeline\n  if (Array.isArray(obj)) {\n    const len = obj.length;\n    for (let i = 0; i < len; ++i) {\n      const ops = Object.keys(obj[i]);\n      for (const op of ops) {\n        obj[i][op] = castPipelineOperator(op, obj[i][op]);\n      }\n    }\n    return obj;\n  }\n  if (schema != null && filter != null && utils.hasUserDefinedProperty(filter, schema.options.discriminatorKey) && typeof filter[schema.options.discriminatorKey] !== 'object' && schema.discriminators != null) {\n    const discriminatorValue = filter[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] || byValue && byValue.schema || schema;\n  } else if (schema != null && options.overwriteDiscriminatorKey && utils.hasUserDefinedProperty(obj, schema.options.discriminatorKey) && schema.discriminators != null) {\n    const discriminatorValue = obj[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] || byValue && byValue.schema || schema;\n  } else if (schema != null && options.overwriteDiscriminatorKey && obj.$set != null && utils.hasUserDefinedProperty(obj.$set, schema.options.discriminatorKey) && schema.discriminators != null) {\n    const discriminatorValue = obj.$set[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] || byValue && byValue.schema || schema;\n  }\n  if (options.upsert) {\n    moveImmutableProperties(schema, obj, context);\n  }\n  const ops = Object.keys(obj);\n  let i = ops.length;\n  const ret = {};\n  let val;\n  let hasDollarKey = false;\n  filter = filter || {};\n  while (i--) {\n    const op = ops[i];\n    if (!mongodbUpdateOperators.has(op)) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n  // cast each value\n  i = ops.length;\n  while (i--) {\n    const op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.startsWith('$');\n    if (val != null && val.$__) {\n      val = val.toObject(internalToObjectOptions);\n      ret[op] = val;\n    }\n    if (val && typeof val === 'object' && !Buffer.isBuffer(val) && mongodbUpdateOperators.has(op)) {\n      walkUpdatePath(schema, val, op, options, context, filter);\n    } else {\n      const msg = 'Invalid atomic update value for ' + op + '. ' + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n    if (op.startsWith('$') && utils.isEmptyObject(val)) {\n      delete ret[op];\n    }\n  }\n  if (Object.keys(ret).length === 0 && options.upsert && Object.keys(filter).length > 0) {\n    // Trick the driver into allowing empty upserts to work around\n    // https://github.com/mongodb/node-mongodb-native/pull/2490\n    // Shallow clone to avoid passing defaults in re: gh-13962\n    return {\n      $setOnInsert: {\n        ...filter\n      }\n    };\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction castPipelineOperator(op, val) {\n  if (op === '$unset') {\n    if (typeof val !== 'string' && (!Array.isArray(val) || val.find(v => typeof v !== 'string'))) {\n      throw new MongooseError('Invalid $unset in pipeline, must be ' + ' a string or an array of strings');\n    }\n    return val;\n  }\n  if (op === '$project') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid $project in pipeline, must be an object');\n    }\n    return val;\n  }\n  if (op === '$addFields' || op === '$set') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  } else if (op === '$replaceRoot' || op === '$replaceWith') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  }\n  throw new MongooseError('Invalid update pipeline operator: \"' + op + '\"');\n}\n\n/**\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj part of a query\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict]\n * @param {Query} context\n * @param {Object} filter\n * @param {String} pref path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nfunction walkUpdatePath(schema, obj, op, options, context, filter, prefix) {\n  const strict = options.strict;\n  prefix = prefix ? prefix + '.' : '';\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys = false;\n  let schematype;\n  let key;\n  let val;\n  let aggregatedError = null;\n  const strictMode = strict != null ? strict : schema.options.strict;\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    // `$pull` is special because we need to cast the RHS as a query, not as\n    // an update.\n    if (op === '$pull') {\n      schematype = schema._getSchema(prefix + key);\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n      if (schematype != null && schematype.schema != null) {\n        obj[key] = cast(schematype.schema, obj[key], options, context);\n        hasKeys = true;\n        continue;\n      }\n    }\n    const discriminatorKey = prefix ? prefix + key : key;\n    if (schema.discriminatorMapping != null && discriminatorKey === schema.options.discriminatorKey && schema.discriminatorMapping.value !== obj[key] && !options.overwriteDiscriminatorKey) {\n      if (strictMode === 'throw') {\n        const err = new Error('Can\\'t modify discriminator key \"' + discriminatorKey + '\" on discriminator model');\n        aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);\n        continue;\n      } else if (strictMode) {\n        delete obj[key];\n        continue;\n      }\n    }\n    if (getConstructorName(val) === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n      if (op !== '$setOnInsert' && handleImmutable(schematype, strict, obj, key, prefix + key, options, context)) {\n        continue;\n      }\n      if (schematype && (schematype.embeddedSchemaType || schematype.Constructor) && op in castOps) {\n        // embedded doc schema\n        if ('$each' in val) {\n          hasKeys = true;\n          try {\n            obj[key] = {\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\n            };\n          } catch (error) {\n            aggregatedError = _appendError(error, context, key, aggregatedError);\n          }\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n          if (val.$position != null) {\n            obj[key].$position = castNumber(val.$position);\n          }\n        } else {\n          if (schematype != null && schematype.$isSingleNested) {\n            const _strict = strict == null ? schematype.schema.options.strict : strict;\n            try {\n              obj[key] = schematype.castForQuery(null, val, context, {\n                strict: _strict\n              });\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          } else {\n            try {\n              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          }\n          if (obj[key] === void 0) {\n            delete obj[key];\n            continue;\n          }\n          hasKeys = true;\n        }\n      } else if (op === '$currentDate' || op in castOps && schematype) {\n        // $currentDate can take an object\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n        hasKeys = true;\n      } else if (op === '$rename') {\n        const schematype = new SchemaString(`${prefix}${key}.$rename`);\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n        hasKeys = true;\n      } else {\n        const pathToCheck = prefix + key;\n        const v = schema._getPathType(pathToCheck);\n        let _strict = strict;\n        if (v && v.schema && _strict == null) {\n          _strict = v.schema.options.strict;\n        }\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) || utils.isObject(val) && Object.keys(val).length === 0;\n      }\n    } else {\n      const isModifier = key === '$each' || key === '$or' || key === '$and' || key === '$in';\n      if (isModifier && !prefix) {\n        throw new MongooseError('Invalid update: Unexpected modifier \"' + key + '\" as a key in operator. ' + 'Did you mean something like { $addToSet: { fieldName: { $each: [...] } } }? ' + 'Modifiers such as \"$each\", \"$or\", \"$and\", \"$in\" must appear under a valid field path.');\n      }\n      const checkPath = isModifier ? prefix : prefix + key;\n      schematype = schema._getSchema(checkPath);\n\n      // You can use `$setOnInsert` with immutable keys\n      if (op !== '$setOnInsert' && handleImmutable(schematype, strict, obj, key, prefix + key, options, context)) {\n        continue;\n      }\n      let pathDetails = schema._getPathType(checkPath);\n\n      // If no schema type, check for embedded discriminators because the\n      // filter or update may imply an embedded discriminator type. See #8378\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n          pathDetails = _res.type;\n        }\n      }\n      let isStrict = strict;\n      if (pathDetails && pathDetails.schema && strict == null) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n      const skip = isStrict && !schematype && !/real|nested/.test(pathDetails.pathType);\n      if (skip) {\n        // Even if strict is `throw`, avoid throwing an error because of\n        // virtuals because of #6731\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        if (op === '$rename') {\n          if (obj[key] == null) {\n            throw new CastError('String', obj[key], `${prefix}${key}.$rename`);\n          }\n          const schematype = new SchemaString(`${prefix}${key}.$rename`, null, null, schema);\n          obj[key] = schematype.castForQuery(null, obj[key], context);\n          continue;\n        }\n        try {\n          if (prefix.length === 0 || key.indexOf('.') === -1) {\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n          } else if (isStrict !== false || schematype != null) {\n            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in\n            // a schema, so replace the dotted path with a nested object to avoid ending up with\n            // dotted properties in the updated object. See (gh-10200)\n            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));\n            delete obj[key];\n          }\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\n          if (schematype && schematype.embeddedSchemaType && !schematype.embeddedSchemaType.$isMongooseArray && !schematype.embeddedSchemaType[schemaMixedSymbol]) {\n            obj[key] = {\n              $each: obj[key]\n            };\n          }\n        }\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n        hasKeys = true;\n      }\n    }\n  }\n  if (aggregatedError != null) {\n    throw aggregatedError;\n  }\n  return hasKeys;\n}\n\n/*!\n * ignore\n */\n\nfunction _appendError(error, query, key, aggregatedError) {\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\n    throw error;\n  }\n  aggregatedError = aggregatedError || new ValidationError();\n  aggregatedError.addError(key, error);\n  return aggregatedError;\n}\n\n/**\n * These operators should be cast to numbers instead\n * of their path schema type.\n * @api private\n */\n\nconst numberOps = {\n  $pop: 1,\n  $inc: 1\n};\n\n/**\n * These ops require no casting because the RHS doesn't do anything.\n * @api private\n */\n\nconst noCastOps = {\n  $unset: 1\n};\n\n/**\n * These operators require casting docs\n * to real Documents for Update operations.\n * @api private\n */\n\nconst castOps = {\n  $push: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * ignore\n */\n\nconst overwriteOps = {\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/**\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {String} $conditional\n * @param {Query} context\n * @param {String} path\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\n  if (!schema) {\n    // non-existing schema path\n    if (op in numberOps) {\n      try {\n        return castNumber(val);\n      } catch {\n        throw new CastError('number', val, path);\n      }\n    }\n    return val;\n  }\n  const cond = schema.$isMongooseArray && op in castOps && (utils.isObject(val) || Array.isArray(val));\n  if (cond && !overwriteOps[op]) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    let schemaArrayDepth = 0;\n    let cur = schema;\n    while (cur.$isMongooseArray) {\n      ++schemaArrayDepth;\n      cur = cur.embeddedSchemaType;\n    }\n    let arrayDepth = 0;\n    let _val = val;\n    while (Array.isArray(_val)) {\n      ++arrayDepth;\n      _val = _val[0];\n    }\n    const additionalNesting = schemaArrayDepth - arrayDepth;\n    while (arrayDepth < schemaArrayDepth) {\n      val = [val];\n      ++arrayDepth;\n    }\n    let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);\n    for (let i = 0; i < additionalNesting; ++i) {\n      tmp = tmp[0];\n    }\n    return tmp;\n  }\n  if (op in noCastOps) {\n    return val;\n  }\n  if (op in numberOps) {\n    // Null and undefined not allowed for $pop, $inc\n    if (val == null) {\n      throw new CastError('number', val, schema.path);\n    }\n    if (op === '$inc') {\n      // Support `$inc` with long, int32, etc. (gh-4283)\n      return schema.castForQuery(null, val, context);\n    }\n    try {\n      return castNumber(val);\n    } catch {\n      throw new CastError('number', val, schema.path);\n    }\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return {\n        $type: val.$type\n      };\n    }\n    return Boolean(val);\n  }\n  if (mongodbUpdateOperators.has($conditional)) {\n    return schema.castForQuery($conditional, val, context);\n  }\n  if (overwriteOps[op]) {\n    const skipQueryCastForUpdate = val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\\d+$/);\n    const applySetters = schema[schemaMixedSymbol] != null;\n    if (skipQueryCastForUpdate || applySetters) {\n      return schema.applySetters(val, context);\n    }\n    return schema.castForQuery(null, val, context);\n  }\n  return schema.castForQuery(null, val, context);\n}","map":{"version":3,"names":["CastError","require","MongooseError","SchemaString","StrictModeError","ValidationError","castNumber","cast","getConstructorName","getDiscriminatorByValue","getEmbeddedDiscriminatorPath","handleImmutable","moveImmutableProperties","schemaMixedSymbol","setDottedPath","utils","internalToObjectOptions","mongodbUpdateOperators","Set","module","exports","castUpdate","schema","obj","options","context","filter","undefined","Array","isArray","len","length","i","ops","Object","keys","op","castPipelineOperator","hasUserDefinedProperty","discriminatorKey","discriminators","discriminatorValue","byValue","model","overwriteDiscriminatorKey","$set","upsert","ret","val","hasDollarKey","has","splice","indexOf","push","startsWith","$__","toObject","Buffer","isBuffer","walkUpdatePath","msg","Error","isEmptyObject","$setOnInsert","find","v","prefix","strict","hasKeys","schematype","key","aggregatedError","strictMode","_getSchema","_res","discriminatorMapping","value","err","_appendError","embeddedSchemaType","Constructor","castOps","$each","castUpdateVal","error","$slice","$sort","$position","$isSingleNested","_strict","castForQuery","pathToCheck","_getPathType","pathType","isObject","isModifier","checkPath","pathDetails","type","isStrict","skip","test","virtuals","$isMongooseArray","query","multipleCastError","addError","numberOps","$pop","$inc","noCastOps","$unset","$push","$addToSet","overwriteOps","$conditional","path","cond","schemaArrayDepth","cur","arrayDepth","_val","additionalNesting","tmp","applySetters","$type","Boolean","skipQueryCastForUpdate","$fullPath","match"],"sources":["C:/Users/HP/Desktop/smart attendance/client/node_modules/mongoose/lib/helpers/query/castUpdate.js"],"sourcesContent":["'use strict';\n\nconst CastError = require('../../error/cast');\nconst MongooseError = require('../../error/mongooseError');\nconst SchemaString = require('../../schema/string');\nconst StrictModeError = require('../../error/strict');\nconst ValidationError = require('../../error/validation');\nconst castNumber = require('../../cast/number');\nconst cast = require('../../cast');\nconst getConstructorName = require('../getConstructorName');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst getEmbeddedDiscriminatorPath = require('./getEmbeddedDiscriminatorPath');\nconst handleImmutable = require('./handleImmutable');\nconst moveImmutableProperties = require('../update/moveImmutableProperties');\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst setDottedPath = require('../path/setDottedPath');\nconst utils = require('../../utils');\nconst { internalToObjectOptions } = require('../../options');\n\nconst mongodbUpdateOperators = new Set([\n  '$currentDate',\n  '$inc',\n  '$min',\n  '$max',\n  '$mul',\n  '$rename',\n  '$set',\n  '$setOnInsert',\n  '$unset',\n  '$addToSet',\n  '$pop',\n  '$pull',\n  '$push',\n  '$pullAll',\n  '$bit'\n]);\n\n/**\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict] defaults to true\n * @param {Query} context passed to setters\n * @return {Boolean} true iff the update is non-empty\n * @api private\n */\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\n  if (obj == null) {\n    return undefined;\n  }\n  options = options || {};\n  // Update pipeline\n  if (Array.isArray(obj)) {\n    const len = obj.length;\n    for (let i = 0; i < len; ++i) {\n      const ops = Object.keys(obj[i]);\n      for (const op of ops) {\n        obj[i][op] = castPipelineOperator(op, obj[i][op]);\n      }\n    }\n    return obj;\n  }\n\n  if (schema != null &&\n      filter != null &&\n      utils.hasUserDefinedProperty(filter, schema.options.discriminatorKey) &&\n      typeof filter[schema.options.discriminatorKey] !== 'object' &&\n      schema.discriminators != null) {\n    const discriminatorValue = filter[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] ||\n      (byValue && byValue.schema) ||\n      schema;\n  } else if (schema != null &&\n      options.overwriteDiscriminatorKey &&\n      utils.hasUserDefinedProperty(obj, schema.options.discriminatorKey) &&\n      schema.discriminators != null) {\n    const discriminatorValue = obj[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] ||\n      (byValue && byValue.schema) ||\n      schema;\n  } else if (schema != null &&\n      options.overwriteDiscriminatorKey &&\n      obj.$set != null &&\n      utils.hasUserDefinedProperty(obj.$set, schema.options.discriminatorKey) &&\n      schema.discriminators != null) {\n    const discriminatorValue = obj.$set[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] ||\n      (byValue && byValue.schema) ||\n      schema;\n  }\n\n  if (options.upsert) {\n    moveImmutableProperties(schema, obj, context);\n  }\n\n  const ops = Object.keys(obj);\n  let i = ops.length;\n  const ret = {};\n  let val;\n  let hasDollarKey = false;\n\n  filter = filter || {};\n  while (i--) {\n    const op = ops[i];\n    if (!mongodbUpdateOperators.has(op)) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n  // cast each value\n  i = ops.length;\n  while (i--) {\n    const op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.startsWith('$');\n    if (val != null && val.$__) {\n      val = val.toObject(internalToObjectOptions);\n      ret[op] = val;\n    }\n    if (val &&\n        typeof val === 'object' &&\n        !Buffer.isBuffer(val) &&\n        mongodbUpdateOperators.has(op)) {\n      walkUpdatePath(schema, val, op, options, context, filter);\n    } else {\n      const msg = 'Invalid atomic update value for ' + op + '. '\n          + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n\n    if (op.startsWith('$') && utils.isEmptyObject(val)) {\n      delete ret[op];\n    }\n  }\n\n  if (Object.keys(ret).length === 0 &&\n      options.upsert &&\n      Object.keys(filter).length > 0) {\n    // Trick the driver into allowing empty upserts to work around\n    // https://github.com/mongodb/node-mongodb-native/pull/2490\n    // Shallow clone to avoid passing defaults in re: gh-13962\n    return { $setOnInsert: { ...filter } };\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction castPipelineOperator(op, val) {\n  if (op === '$unset') {\n    if (typeof val !== 'string' && (!Array.isArray(val) || val.find(v => typeof v !== 'string'))) {\n      throw new MongooseError('Invalid $unset in pipeline, must be ' +\n        ' a string or an array of strings');\n    }\n    return val;\n  }\n  if (op === '$project') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid $project in pipeline, must be an object');\n    }\n    return val;\n  }\n  if (op === '$addFields' || op === '$set') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  } else if (op === '$replaceRoot' || op === '$replaceWith') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  }\n\n  throw new MongooseError('Invalid update pipeline operator: \"' + op + '\"');\n}\n\n/**\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj part of a query\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict]\n * @param {Query} context\n * @param {Object} filter\n * @param {String} pref path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nfunction walkUpdatePath(schema, obj, op, options, context, filter, prefix) {\n  const strict = options.strict;\n  prefix = prefix ? prefix + '.' : '';\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys = false;\n  let schematype;\n  let key;\n  let val;\n\n  let aggregatedError = null;\n\n  const strictMode = strict != null ? strict : schema.options.strict;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    // `$pull` is special because we need to cast the RHS as a query, not as\n    // an update.\n    if (op === '$pull') {\n      schematype = schema._getSchema(prefix + key);\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n      if (schematype != null && schematype.schema != null) {\n        obj[key] = cast(schematype.schema, obj[key], options, context);\n        hasKeys = true;\n        continue;\n      }\n    }\n\n    const discriminatorKey = (prefix ? prefix + key : key);\n    if (\n      schema.discriminatorMapping != null &&\n      discriminatorKey === schema.options.discriminatorKey &&\n      schema.discriminatorMapping.value !== obj[key] &&\n      !options.overwriteDiscriminatorKey\n    ) {\n      if (strictMode === 'throw') {\n        const err = new Error('Can\\'t modify discriminator key \"' + discriminatorKey + '\" on discriminator model');\n        aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);\n        continue;\n      } else if (strictMode) {\n        delete obj[key];\n        continue;\n      }\n    }\n\n    if (getConstructorName(val) === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n\n      if (op !== '$setOnInsert' &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, options, context)) {\n        continue;\n      }\n\n      if (schematype && (schematype.embeddedSchemaType || schematype.Constructor) && op in castOps) {\n        // embedded doc schema\n        if ('$each' in val) {\n          hasKeys = true;\n          try {\n            obj[key] = {\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\n            };\n          } catch (error) {\n            aggregatedError = _appendError(error, context, key, aggregatedError);\n          }\n\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n\n          if (val.$position != null) {\n            obj[key].$position = castNumber(val.$position);\n          }\n        } else {\n          if (schematype != null && schematype.$isSingleNested) {\n            const _strict = strict == null ? schematype.schema.options.strict : strict;\n            try {\n              obj[key] = schematype.castForQuery(null, val, context, { strict: _strict });\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          } else {\n            try {\n              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          }\n\n          if (obj[key] === void 0) {\n            delete obj[key];\n            continue;\n          }\n\n          hasKeys = true;\n        }\n      } else if ((op === '$currentDate') || (op in castOps && schematype)) {\n        // $currentDate can take an object\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      } else if (op === '$rename') {\n        const schematype = new SchemaString(`${prefix}${key}.$rename`);\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      } else {\n        const pathToCheck = (prefix + key);\n        const v = schema._getPathType(pathToCheck);\n        let _strict = strict;\n        if (v && v.schema && _strict == null) {\n          _strict = v.schema.options.strict;\n        }\n\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) ||\n          (utils.isObject(val) && Object.keys(val).length === 0);\n      }\n    } else {\n      const isModifier = (key === '$each' || key === '$or' || key === '$and' || key === '$in');\n      if (isModifier && !prefix) {\n        throw new MongooseError('Invalid update: Unexpected modifier \"' + key + '\" as a key in operator. '\n          + 'Did you mean something like { $addToSet: { fieldName: { $each: [...] } } }? '\n          + 'Modifiers such as \"$each\", \"$or\", \"$and\", \"$in\" must appear under a valid field path.');\n      }\n      const checkPath = isModifier ? prefix : prefix + key;\n      schematype = schema._getSchema(checkPath);\n\n      // You can use `$setOnInsert` with immutable keys\n      if (op !== '$setOnInsert' &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, options, context)) {\n        continue;\n      }\n\n      let pathDetails = schema._getPathType(checkPath);\n\n      // If no schema type, check for embedded discriminators because the\n      // filter or update may imply an embedded discriminator type. See #8378\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n          pathDetails = _res.type;\n        }\n      }\n\n      let isStrict = strict;\n      if (pathDetails && pathDetails.schema && strict == null) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n\n      const skip = isStrict &&\n        !schematype &&\n        !/real|nested/.test(pathDetails.pathType);\n\n      if (skip) {\n        // Even if strict is `throw`, avoid throwing an error because of\n        // virtuals because of #6731\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        if (op === '$rename') {\n          if (obj[key] == null) {\n            throw new CastError('String', obj[key], `${prefix}${key}.$rename`);\n          }\n          const schematype = new SchemaString(`${prefix}${key}.$rename`, null, null, schema);\n          obj[key] = schematype.castForQuery(null, obj[key], context);\n          continue;\n        }\n\n        try {\n          if (prefix.length === 0 || key.indexOf('.') === -1) {\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n          } else if (isStrict !== false || schematype != null) {\n            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in\n            // a schema, so replace the dotted path with a nested object to avoid ending up with\n            // dotted properties in the updated object. See (gh-10200)\n            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));\n            delete obj[key];\n          }\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\n          if (schematype &&\n              schematype.embeddedSchemaType &&\n              !schematype.embeddedSchemaType.$isMongooseArray &&\n              !schematype.embeddedSchemaType[schemaMixedSymbol]) {\n            obj[key] = { $each: obj[key] };\n          }\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      }\n    }\n  }\n\n  if (aggregatedError != null) {\n    throw aggregatedError;\n  }\n\n  return hasKeys;\n}\n\n/*!\n * ignore\n */\n\nfunction _appendError(error, query, key, aggregatedError) {\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\n    throw error;\n  }\n  aggregatedError = aggregatedError || new ValidationError();\n  aggregatedError.addError(key, error);\n  return aggregatedError;\n}\n\n/**\n * These operators should be cast to numbers instead\n * of their path schema type.\n * @api private\n */\n\nconst numberOps = {\n  $pop: 1,\n  $inc: 1\n};\n\n/**\n * These ops require no casting because the RHS doesn't do anything.\n * @api private\n */\n\nconst noCastOps = {\n  $unset: 1\n};\n\n/**\n * These operators require casting docs\n * to real Documents for Update operations.\n * @api private\n */\n\nconst castOps = {\n  $push: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * ignore\n */\n\nconst overwriteOps = {\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/**\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {String} $conditional\n * @param {Query} context\n * @param {String} path\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\n  if (!schema) {\n    // non-existing schema path\n    if (op in numberOps) {\n      try {\n        return castNumber(val);\n      } catch {\n        throw new CastError('number', val, path);\n      }\n    }\n    return val;\n  }\n\n  const cond = schema.$isMongooseArray\n    && op in castOps\n    && (utils.isObject(val) || Array.isArray(val));\n  if (cond && !overwriteOps[op]) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    let schemaArrayDepth = 0;\n    let cur = schema;\n    while (cur.$isMongooseArray) {\n      ++schemaArrayDepth;\n      cur = cur.embeddedSchemaType;\n    }\n    let arrayDepth = 0;\n    let _val = val;\n    while (Array.isArray(_val)) {\n      ++arrayDepth;\n      _val = _val[0];\n    }\n\n    const additionalNesting = schemaArrayDepth - arrayDepth;\n    while (arrayDepth < schemaArrayDepth) {\n      val = [val];\n      ++arrayDepth;\n    }\n\n    let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);\n\n    for (let i = 0; i < additionalNesting; ++i) {\n      tmp = tmp[0];\n    }\n    return tmp;\n  }\n\n  if (op in noCastOps) {\n    return val;\n  }\n  if (op in numberOps) {\n    // Null and undefined not allowed for $pop, $inc\n    if (val == null) {\n      throw new CastError('number', val, schema.path);\n    }\n    if (op === '$inc') {\n      // Support `$inc` with long, int32, etc. (gh-4283)\n      return schema.castForQuery(\n        null,\n        val,\n        context\n      );\n    }\n    try {\n      return castNumber(val);\n    } catch {\n      throw new CastError('number', val, schema.path);\n    }\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return { $type: val.$type };\n    }\n    return Boolean(val);\n  }\n\n  if (mongodbUpdateOperators.has($conditional)) {\n    return schema.castForQuery(\n      $conditional,\n      val,\n      context\n    );\n  }\n\n  if (overwriteOps[op]) {\n    const skipQueryCastForUpdate = val != null\n      && schema.$isMongooseArray\n      && schema.$fullPath != null\n      && !schema.$fullPath.match(/\\d+$/);\n    const applySetters = schema[schemaMixedSymbol] != null;\n    if (skipQueryCastForUpdate || applySetters) {\n      return schema.applySetters(val, context);\n    }\n    return schema.castForQuery(\n      null,\n      val,\n      context\n    );\n  }\n\n  return schema.castForQuery(null, val, context);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}