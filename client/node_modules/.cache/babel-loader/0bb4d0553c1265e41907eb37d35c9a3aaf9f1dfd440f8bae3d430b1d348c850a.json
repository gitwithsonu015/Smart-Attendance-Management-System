{"ast":null,"code":"'use strict';\n\nconst MongooseError = require('../../error/index');\nconst SkipPopulateValue = require('./skipPopulateValue');\nconst clone = require('../clone');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst getConstructorName = require('../getConstructorName');\nconst getSchemaTypes = require('./getSchemaTypes');\nconst getVirtual = require('./getVirtual');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst modelNamesFromRefPath = require('./modelNamesFromRefPath');\nconst utils = require('../../utils');\nconst modelSymbol = require('../symbols').modelSymbol;\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst StrictPopulate = require('../../error/strictPopulate');\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let doc;\n  const len = docs.length;\n  const map = [];\n  const modelNameFromQuery = options.model && options.model.modelName || options.model;\n  let schema;\n  let refPath;\n  let modelNames;\n  const available = {};\n  const modelSchema = model.schema;\n\n  // Populating a nested path should always be a no-op re: #9073.\n  // People shouldn't do this, but apparently they do.\n  if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n    return [];\n  }\n  const _virtualRes = getVirtual(model.schema, options.path);\n  const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n  if (virtual != null) {\n    return _virtualPopulate(model, docs, options, _virtualRes);\n  }\n  let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n  const isStrictPopulateDisabled = options.strictPopulate === false || options.options?.strictPopulate === false;\n  if (!isStrictPopulateDisabled && allSchemaTypes.length === 0 && options._localModel != null) {\n    return new StrictPopulate(options._fullPath || options.path);\n  }\n  for (let i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n    if (doc.$__ != null && doc.populated(options.path)) {\n      const forceRepopulate = options.forceRepopulate != null ? options.forceRepopulate : doc.constructor.base.options.forceRepopulate;\n      if (forceRepopulate === false) {\n        continue;\n      }\n    }\n    const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;\n    schema = getSchemaTypes(model, docSchema, doc, options.path);\n\n    // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n    if (schema != null && schema.$isMongooseDocumentArray && schema.options.ref == null && schema.options.refPath == null) {\n      continue;\n    }\n    const isUnderneathDocArray = schema && schema.$parentSchemaDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path + ' because it is a subproperty of a document array');\n    }\n    modelNames = null;\n    let isRefPath = false;\n    let normalizedRefPath = null;\n    let schemaOptions = null;\n    let modelNamesInOrder = null;\n    if (schema != null && schema.instance === 'Embedded') {\n      if (schema.options.ref) {\n        const data = {\n          localField: options.path + '._id',\n          foreignField: '_id',\n          justOne: true\n        };\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        const unpopulatedValue = mpath.get(options.path, doc);\n        const id = mpath.get('_id', unpopulatedValue);\n        addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);\n      }\n      // No-op if no `ref` set. See gh-11538\n      continue;\n    }\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n      for (const _schema of schemasArray) {\n        let _modelNames;\n        let res;\n        try {\n          res = _getModelNames(doc, _schema, modelNameFromQuery, model);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizedRefPath || res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        for (const modelName of _modelNames) {\n          if (modelNames.indexOf(modelName) === -1) {\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = normalizedRefPath || res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null);\n        // Dedupe, because `refPath` can return duplicates of the same model name,\n        // and that causes perf issues.\n        if (isRefPath) {\n          modelNamesInOrder = modelNames;\n          modelNames = Array.from(new Set(modelNames));\n        }\n      } catch (error) {\n        return error;\n      }\n      if (!modelNames) {\n        continue;\n      }\n    }\n    const data = {};\n    const localField = options.path;\n    const foreignField = '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path) || options.path === schema.path) {\n        justOne = Array.isArray(schema) ? schema.every(schema => !schema.$isMongooseArray) : !schema.$isMongooseArray;\n      }\n    }\n    if (!modelNames) {\n      continue;\n    }\n    data.isVirtual = false;\n    data.justOne = justOne;\n    data.localField = localField;\n    data.foreignField = foreignField;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n    let match = get(options, 'match', null);\n    const hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n    throwOn$where(match);\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    data.isRefPath = isRefPath;\n    data.modelNamesInOrder = modelNamesInOrder;\n    if (isRefPath) {\n      const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret);\n      modelNames = embeddedDiscriminatorModelNames || modelNames;\n    }\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n  function _getModelNames(doc, schema, modelNameFromQuery, model) {\n    let modelNames;\n    let isRefPath = false;\n    let justOne = null;\n    const originalSchema = schema;\n    if (schema && schema.instance === 'Array') {\n      schema = schema.embeddedSchemaType;\n    }\n    if (schema && schema.$isSchemaMap) {\n      schema = schema.$__schemaType;\n    }\n    const ref = schema && schema.options && schema.options.ref;\n    refPath = schema && schema.options && schema.options.refPath;\n    if (schema != null && schema[schemaMixedSymbol] && !ref && !refPath && !modelNameFromQuery) {\n      return {\n        modelNames: null\n      };\n    }\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (refPath != null) {\n      if (typeof refPath === 'function') {\n        const subdocPath = options.path.slice(0, options.path.length - schema.path.length - 1);\n        const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n        const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];\n        modelNames = new Set();\n        for (const subdoc of subdocsBeingPopulated) {\n          refPath = refPath.call(subdoc, subdoc, options.path);\n          modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).forEach(name => modelNames.add(name));\n        }\n        modelNames = Array.from(modelNames);\n      } else {\n        modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n      }\n      isRefPath = true;\n    } else {\n      let ref;\n      let refPath;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n      let modelForCurrentDoc = model;\n      const discriminatorKey = model.schema.options.discriminatorKey;\n      if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n        if (schemaForCurrentDoc && schemaForCurrentDoc.embeddedSchemaType) {\n          schemaForCurrentDoc = schemaForCurrentDoc.embeddedSchemaType;\n        }\n      } else {\n        schemaForCurrentDoc = schema;\n      }\n      if (originalSchema && originalSchema.path.endsWith('.$*')) {\n        justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;\n      } else if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        if (schemaForCurrentDoc != null && typeof ref === 'function' && options.path.endsWith('.' + schemaForCurrentDoc.path)) {\n          // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469\n          modelNames = new Set();\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];\n          for (const subdoc of subdocsBeingPopulated) {\n            modelNames.add(handleRefFunction(ref, subdoc));\n          }\n          if (subdocsBeingPopulated.length === 0) {\n            modelNames = [handleRefFunction(ref, doc)];\n          } else {\n            modelNames = Array.from(modelNames);\n          }\n        } else {\n          ref = handleRefFunction(ref, doc);\n          modelNames = [ref];\n        }\n      } else if ((schemaForCurrentDoc = get(schema, 'options.refPath')) != null) {\n        isRefPath = true;\n        if (typeof refPath === 'function') {\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];\n          modelNames = new Set();\n          for (const subdoc of subdocsBeingPopulated) {\n            refPath = refPath.call(subdoc, subdoc, options.path);\n            modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).forEach(name => modelNames.add(name));\n          }\n          modelNames = Array.from(modelNames);\n        } else {\n          modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n        }\n      }\n    }\n    if (!modelNames) {\n      // `Model.populate()` on a POJO with no known local model. Default to using the `Model`\n      if (options._localModel == null) {\n        modelNames = [model.modelName];\n      } else {\n        return {\n          modelNames: modelNames,\n          justOne: justOne,\n          isRefPath: isRefPath,\n          refPath: refPath\n        };\n      }\n    }\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n    return {\n      modelNames: modelNames,\n      justOne: justOne,\n      isRefPath: isRefPath,\n      refPath: refPath\n    };\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _virtualPopulate(model, docs, options, _virtualRes) {\n  const map = [];\n  const available = {};\n  const virtual = _virtualRes.virtual;\n  for (const doc of docs) {\n    let modelNames = null;\n    const data = {};\n\n    // localField and foreignField\n    let localField;\n    const virtualPrefix = _virtualRes.nestedSchemaPath ? _virtualRes.nestedSchemaPath + '.' : '';\n    if (typeof options.localField === 'string') {\n      localField = options.localField;\n    } else if (typeof virtual.options.localField === 'function') {\n      localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n    } else if (Array.isArray(virtual.options.localField)) {\n      localField = virtual.options.localField.map(field => virtualPrefix + field);\n    } else {\n      localField = virtualPrefix + virtual.options.localField;\n    }\n    data.count = virtual.options.count;\n    if (virtual.options.skip != null && !Object.hasOwn(options, 'skip')) {\n      options.skip = virtual.options.skip;\n    }\n    if (virtual.options.limit != null && !Object.hasOwn(options, 'limit')) {\n      options.limit = virtual.options.limit;\n    }\n    if (virtual.options.perDocumentLimit != null && !Object.hasOwn(options, 'perDocumentLimit')) {\n      options.perDocumentLimit = virtual.options.perDocumentLimit;\n    }\n    let foreignField = virtual.options.foreignField;\n    if (!localField || !foreignField) {\n      return new MongooseError(`Cannot populate virtual \\`${options.path}\\` on model \\`${model.modelName}\\`, because options \\`localField\\` and / or \\`foreignField\\` are missing`);\n    }\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc, doc);\n    }\n    data.isRefPath = false;\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    let justOne = null;\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    }\n\n    // Use the correct target doc/sub-doc for dynamic ref on nested schema. See gh-12363\n    if (_virtualRes.nestedSchemaPath && typeof virtual.options.ref === 'function') {\n      const subdocs = utils.getValue(_virtualRes.nestedSchemaPath, doc);\n      modelNames = Array.isArray(subdocs) ? subdocs.flatMap(subdoc => virtual._getModelNamesForPopulate(subdoc)) : virtual._getModelNamesForPopulate(subdocs);\n    } else {\n      modelNames = virtual._getModelNamesForPopulate(doc);\n    }\n    if (virtual.options.refPath) {\n      justOne = !!virtual.options.justOne;\n      data.isRefPath = true;\n    } else if (virtual.options.ref) {\n      justOne = !!virtual.options.justOne;\n    }\n    data.isVirtual = true;\n    data.virtual = virtual;\n    data.justOne = justOne;\n\n    // `match`\n    const baseMatch = get(data, 'virtual.options.match', null) || get(data, 'virtual.options.options.match', null);\n    let match = get(options, 'match', null) || baseMatch;\n    let hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc, data.virtual);\n    }\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);\n        hasMatchFunction = true;\n      }\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n    data.localField = localField;\n    data.foreignField = foreignField;\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    throwOn$where(match);\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, virtual);\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n}\n\n/*!\n * ignore\n */\n\nfunction addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {\n  // `PopulateOptions#connection`: if the model is passed as a string, the\n  // connection matters because different connections have different models.\n  const connection = options.connection != null ? options.connection : model.db;\n  unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;\n  if (Array.isArray(unpopulatedValue)) {\n    unpopulatedValue = utils.cloneArrays(unpopulatedValue);\n  }\n  if (modelNames == null) {\n    return;\n  }\n  const flatModelNames = utils.array.flatten(modelNames);\n  let k = flatModelNames.length;\n  while (k--) {\n    let modelName = flatModelNames[k];\n    if (modelName == null) {\n      continue;\n    }\n    let Model;\n    if (options.model && options.model[modelSymbol]) {\n      Model = options.model;\n    } else if (modelName[modelSymbol]) {\n      Model = modelName;\n      modelName = Model.modelName;\n    } else {\n      try {\n        Model = _getModelFromConn(connection, modelName);\n      } catch (err) {\n        if (ret !== void 0) {\n          throw err;\n        }\n        Model = null;\n      }\n    }\n    let ids = ret;\n    const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;\n    if (data.isRefPath && Array.isArray(ret) && ret.length === modelNamesForRefPath.length) {\n      ids = matchIdsToRefPaths(ret, modelNamesForRefPath, modelName);\n    }\n    const perDocumentLimit = options.perDocumentLimit == null ? get(options, 'options.perDocumentLimit', null) : options.perDocumentLimit;\n    if (!available[modelName] || perDocumentLimit != null) {\n      const currentOptions = {\n        model: Model\n      };\n      if (data.isVirtual && get(data.virtual, 'options.options')) {\n        currentOptions.options = clone(data.virtual.options.options);\n      } else if (schemaOptions != null) {\n        currentOptions.options = Object.assign({}, schemaOptions);\n      }\n      utils.merge(currentOptions, options);\n\n      // Used internally for checking what model was used to populate this\n      // path.\n      options[populateModelSymbol] = Model;\n      currentOptions[populateModelSymbol] = Model;\n      available[modelName] = {\n        model: Model,\n        options: currentOptions,\n        match: data.hasMatchFunction ? [data.match] : data.match,\n        docs: [doc],\n        ids: [ids],\n        allIds: [ret],\n        unpopulatedValues: [unpopulatedValue],\n        localField: new Set([data.localField]),\n        foreignField: new Set([data.foreignField]),\n        justOne: data.justOne,\n        isVirtual: data.isVirtual,\n        virtual: data.virtual,\n        count: data.count,\n        [populateModelSymbol]: Model\n      };\n      map.push(available[modelName]);\n    } else {\n      available[modelName].localField.add(data.localField);\n      available[modelName].foreignField.add(data.foreignField);\n      available[modelName].docs.push(doc);\n      available[modelName].ids.push(ids);\n      available[modelName].allIds.push(ret);\n      available[modelName].unpopulatedValues.push(unpopulatedValue);\n      if (data.hasMatchFunction) {\n        available[modelName].match.push(data.match);\n      }\n    }\n  }\n}\nfunction _getModelFromConn(conn, modelName) {\n  /* If this connection has a parent from `useDb()`, bubble up to parent's models */\n  if (conn.models[modelName] == null && conn._parent != null) {\n    return _getModelFromConn(conn._parent, modelName);\n  }\n  return conn.model(modelName);\n}\nfunction matchIdsToRefPaths(ids, refPaths, refPathToFind) {\n  if (!Array.isArray(refPaths)) {\n    return refPaths === refPathToFind ? Array.isArray(ids) ? utils.array.flatten(ids) : [ids] : [];\n  }\n  if (Array.isArray(ids) && Array.isArray(refPaths)) {\n    return ids.flatMap((id, index) => matchIdsToRefPaths(id, refPaths[index], refPathToFind));\n  }\n  return [];\n}\n\n/*!\n * ignore\n */\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n  return ref;\n}\n\n/*!\n * ignore\n */\n\nfunction _getLocalFieldValues(doc, localField, model, options, virtual, schema) {\n  // Get Local fields\n  const localFieldPathType = model.schema._getPathType(localField);\n  const localFieldPath = localFieldPathType === 'real' ? model.schema.path(localField) : localFieldPathType.schema;\n  const localFieldGetters = localFieldPath && localFieldPath.getters ? localFieldPath.getters : [];\n  localField = localFieldPath != null && localFieldPath.instance === 'Embedded' ? localField + '._id' : localField;\n  const _populateOptions = get(options, 'options', {});\n  const getters = 'getters' in _populateOptions ? _populateOptions.getters : get(virtual, 'options.getters', false);\n  if (localFieldGetters.length !== 0 && getters) {\n    const hydratedDoc = doc.$__ != null ? doc : model.hydrate(doc);\n    const localFieldValue = utils.getValue(localField, doc);\n    if (Array.isArray(localFieldValue)) {\n      const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);\n      return localFieldValue.map((localFieldArrVal, localFieldArrIndex) => localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n    } else {\n      return localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n    }\n  } else {\n    return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n  }\n}\n\n/**\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @param {Schema} schema\n * @return {Array|Document|Any}\n * @api private\n */\n\nfunction convertTo_id(val, schema) {\n  if (val != null && val.$__ != null) {\n    return val._doc._id;\n  }\n  if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {\n    return val._id;\n  }\n  if (Array.isArray(val)) {\n    const rawVal = val.__array != null ? val.__array : val;\n    for (let i = 0; i < rawVal.length; ++i) {\n      if (rawVal[i] != null && rawVal[i].$__ != null) {\n        rawVal[i] = rawVal[i]._doc._id;\n      }\n    }\n    if (utils.isMongooseArray(val) && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (getConstructorName(val) === 'Object' && (\n  // The intent here is we should only flatten the object if we expect\n  // to get a Map in the end. Avoid doing this for mixed types.\n  schema == null || schema[schemaMixedSymbol] == null)) {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map')`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n  return val;\n}\n\n/*!\n * ignore\n */\n\nfunction _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {\n  // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n  // out embedded discriminator docs that don't have a `refPath` on the\n  // populated path.\n  if (!data.isRefPath || normalizedRefPath == null) {\n    return;\n  }\n  const pieces = normalizedRefPath.split('.');\n  let cur = '';\n  let modelNames = void 0;\n  for (let i = 0; i < pieces.length; ++i) {\n    const piece = pieces[i];\n    cur = cur + (cur.length === 0 ? '' : '.') + piece;\n    const schematype = modelSchema.path(cur);\n    if (schematype != null && schematype.$isMongooseDocumentArray && schematype.Constructor.discriminators != null && Object.keys(schematype.Constructor.discriminators).length !== 0) {\n      const subdocs = utils.getValue(cur, doc);\n      const remnant = options.path.substring(cur.length + 1);\n      const discriminatorKey = schematype.Constructor.schema.options.discriminatorKey;\n      modelNames = [];\n      for (const subdoc of subdocs) {\n        const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n        const discriminator = schematype.Constructor.discriminators[discriminatorName];\n        const discriminatorSchema = discriminator && discriminator.schema;\n        if (discriminatorSchema == null) {\n          continue;\n        }\n        const _path = discriminatorSchema.path(remnant);\n        if (_path == null || _path.options.refPath == null) {\n          const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);\n          ret.forEach((v, i) => {\n            if (v === docValue) {\n              ret[i] = SkipPopulateValue(v);\n            }\n          });\n          continue;\n        }\n        const modelName = utils.getValue(pieces.slice(i + 1).join('.'), subdoc);\n        modelNames.push(modelName);\n      }\n    }\n  }\n  return modelNames;\n}\n\n/**\n * Throw an error if there are any $where keys\n */\n\nfunction throwOn$where(match) {\n  if (match == null) {\n    return;\n  }\n  if (typeof match !== 'object') {\n    return;\n  }\n  for (const key of Object.keys(match)) {\n    if (key === '$where') {\n      throw new MongooseError('Cannot use $where filter with populate() match');\n    }\n    if (match[key] != null && typeof match[key] === 'object') {\n      throwOn$where(match[key]);\n    }\n  }\n}","map":{"version":3,"names":["MongooseError","require","SkipPopulateValue","clone","get","getDiscriminatorByValue","getConstructorName","getSchemaTypes","getVirtual","lookupLocalFields","mpath","modelNamesFromRefPath","utils","modelSymbol","populateModelSymbol","schemaMixedSymbol","StrictPopulate","module","exports","getModelsMapForPopulate","model","docs","options","doc","len","length","map","modelNameFromQuery","modelName","schema","refPath","modelNames","available","modelSchema","_localModel","nested","path","_virtualRes","virtual","_virtualPopulate","allSchemaTypes","Array","isArray","filter","v","isStrictPopulateDisabled","strictPopulate","_fullPath","i","justOne","$__","populated","forceRepopulate","constructor","base","docSchema","$__schema","$isMongooseDocumentArray","ref","isUnderneathDocArray","$parentSchemaDocArray","isRefPath","normalizedRefPath","schemaOptions","modelNamesInOrder","instance","data","localField","foreignField","res","_getModelNames","unpopulatedValue","id","addModelNamesToMap","schemasArray","_schema","_modelNames","error","indexOf","push","from","Set","endsWith","every","$isMongooseArray","isVirtual","ret","_getLocalFieldValues","String","getValue","_docs","slice","match","hasMatchFunction","call","throwOn$where","embeddedDiscriminatorModelNames","_findRefPathForDiscriminators","err","originalSchema","embeddedSchemaType","$isSchemaMap","$__schemaType","subdocPath","vals","subdocsBeingPopulated","array","flatten","subdoc","_queryProjection","forEach","name","add","schemaForCurrentDoc","discriminatorValue","modelForCurrentDoc","discriminatorKey","discriminatorModel","discriminators","_getModelFromConn","db","_getSchema","_arrayPath","handleRefFunction","virtualPrefix","nestedSchemaPath","field","count","skip","Object","hasOwn","limit","perDocumentLimit","subdocs","flatMap","_getModelNamesForPopulate","baseMatch","assign","convertTo_id","connection","cloneArrays","flatModelNames","k","Model","ids","modelNamesForRefPath","matchIdsToRefPaths","currentOptions","merge","allIds","unpopulatedValues","conn","models","_parent","refPaths","refPathToFind","index","localFieldPathType","_getPathType","localFieldPath","localFieldGetters","getters","_populateOptions","hydratedDoc","hydrate","localFieldValue","localFieldHydratedValue","split","localFieldArrVal","localFieldArrIndex","applyGetters","val","_doc","_id","rawVal","__array","isMongooseArray","$schema","_castForPopulate","$parent","concat","key","keys","Map","values","pieces","cur","piece","schematype","Constructor","remnant","substring","discriminatorName","discriminator","discriminatorSchema","_path","docValue","join"],"sources":["C:/Users/HP/Desktop/smart attendance/client/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js"],"sourcesContent":["'use strict';\n\nconst MongooseError = require('../../error/index');\nconst SkipPopulateValue = require('./skipPopulateValue');\nconst clone = require('../clone');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst getConstructorName = require('../getConstructorName');\nconst getSchemaTypes = require('./getSchemaTypes');\nconst getVirtual = require('./getVirtual');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst modelNamesFromRefPath = require('./modelNamesFromRefPath');\nconst utils = require('../../utils');\n\nconst modelSymbol = require('../symbols').modelSymbol;\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst StrictPopulate = require('../../error/strictPopulate');\n\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let doc;\n  const len = docs.length;\n  const map = [];\n  const modelNameFromQuery = options.model && options.model.modelName || options.model;\n  let schema;\n  let refPath;\n  let modelNames;\n  const available = {};\n\n  const modelSchema = model.schema;\n\n  // Populating a nested path should always be a no-op re: #9073.\n  // People shouldn't do this, but apparently they do.\n  if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n    return [];\n  }\n\n  const _virtualRes = getVirtual(model.schema, options.path);\n  const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n  if (virtual != null) {\n    return _virtualPopulate(model, docs, options, _virtualRes);\n  }\n\n  let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n\n  const isStrictPopulateDisabled = options.strictPopulate === false || options.options?.strictPopulate === false;\n  if (!isStrictPopulateDisabled && allSchemaTypes.length === 0 && options._localModel != null) {\n    return new StrictPopulate(options._fullPath || options.path);\n  }\n\n  for (let i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n\n    if (doc.$__ != null && doc.populated(options.path)) {\n      const forceRepopulate = options.forceRepopulate != null ? options.forceRepopulate : doc.constructor.base.options.forceRepopulate;\n      if (forceRepopulate === false) {\n        continue;\n      }\n    }\n\n    const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;\n    schema = getSchemaTypes(model, docSchema, doc, options.path);\n\n    // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n    if (schema != null &&\n        schema.$isMongooseDocumentArray &&\n        schema.options.ref == null &&\n        schema.options.refPath == null) {\n      continue;\n    }\n    const isUnderneathDocArray = schema && schema.$parentSchemaDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path +\n        ' because it is a subproperty of a document array');\n    }\n\n    modelNames = null;\n    let isRefPath = false;\n    let normalizedRefPath = null;\n    let schemaOptions = null;\n    let modelNamesInOrder = null;\n\n    if (schema != null && schema.instance === 'Embedded') {\n      if (schema.options.ref) {\n        const data = {\n          localField: options.path + '._id',\n          foreignField: '_id',\n          justOne: true\n        };\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n\n        const unpopulatedValue = mpath.get(options.path, doc);\n        const id = mpath.get('_id', unpopulatedValue);\n        addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);\n      }\n      // No-op if no `ref` set. See gh-11538\n      continue;\n    }\n\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n      for (const _schema of schemasArray) {\n        let _modelNames;\n        let res;\n        try {\n          res = _getModelNames(doc, _schema, modelNameFromQuery, model);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizedRefPath || res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        for (const modelName of _modelNames) {\n          if (modelNames.indexOf(modelName) === -1) {\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = normalizedRefPath || res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null);\n        // Dedupe, because `refPath` can return duplicates of the same model name,\n        // and that causes perf issues.\n        if (isRefPath) {\n          modelNamesInOrder = modelNames;\n          modelNames = Array.from(new Set(modelNames));\n        }\n      } catch (error) {\n        return error;\n      }\n\n      if (!modelNames) {\n        continue;\n      }\n    }\n\n    const data = {};\n    const localField = options.path;\n    const foreignField = '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path) || options.path === schema.path) {\n        justOne = Array.isArray(schema) ?\n          schema.every(schema => !schema.$isMongooseArray) :\n          !schema.$isMongooseArray;\n      }\n    }\n\n    if (!modelNames) {\n      continue;\n    }\n\n    data.isVirtual = false;\n    data.justOne = justOne;\n    data.localField = localField;\n    data.foreignField = foreignField;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);\n\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n\n    let match = get(options, 'match', null);\n\n    const hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n    throwOn$where(match);\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    data.isRefPath = isRefPath;\n    data.modelNamesInOrder = modelNamesInOrder;\n\n    if (isRefPath) {\n      const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc,\n        modelSchema, data, options, normalizedRefPath, ret);\n\n      modelNames = embeddedDiscriminatorModelNames || modelNames;\n    }\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n\n  function _getModelNames(doc, schema, modelNameFromQuery, model) {\n    let modelNames;\n    let isRefPath = false;\n    let justOne = null;\n\n    const originalSchema = schema;\n    if (schema && schema.instance === 'Array') {\n      schema = schema.embeddedSchemaType;\n    }\n    if (schema && schema.$isSchemaMap) {\n      schema = schema.$__schemaType;\n    }\n\n    const ref = schema && schema.options && schema.options.ref;\n    refPath = schema && schema.options && schema.options.refPath;\n    if (schema != null &&\n        schema[schemaMixedSymbol] &&\n        !ref &&\n        !refPath &&\n        !modelNameFromQuery) {\n      return { modelNames: null };\n    }\n\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (refPath != null) {\n      if (typeof refPath === 'function') {\n        const subdocPath = options.path.slice(0, options.path.length - schema.path.length - 1);\n        const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n        const subdocsBeingPopulated = Array.isArray(vals) ?\n          utils.array.flatten(vals) :\n          (vals ? [vals] : []);\n\n        modelNames = new Set();\n        for (const subdoc of subdocsBeingPopulated) {\n          refPath = refPath.call(subdoc, subdoc, options.path);\n          modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n            forEach(name => modelNames.add(name));\n        }\n        modelNames = Array.from(modelNames);\n      } else {\n        modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n      }\n\n      isRefPath = true;\n    } else {\n      let ref;\n      let refPath;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n      let modelForCurrentDoc = model;\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n\n        if (schemaForCurrentDoc && schemaForCurrentDoc.embeddedSchemaType) {\n          schemaForCurrentDoc = schemaForCurrentDoc.embeddedSchemaType;\n        }\n      } else {\n        schemaForCurrentDoc = schema;\n      }\n\n      if (originalSchema && originalSchema.path.endsWith('.$*')) {\n        justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;\n      } else if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        if (schemaForCurrentDoc != null &&\n            typeof ref === 'function' &&\n            options.path.endsWith('.' + schemaForCurrentDoc.path)) {\n          // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469\n          modelNames = new Set();\n\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n          for (const subdoc of subdocsBeingPopulated) {\n            modelNames.add(handleRefFunction(ref, subdoc));\n          }\n\n          if (subdocsBeingPopulated.length === 0) {\n            modelNames = [handleRefFunction(ref, doc)];\n          } else {\n            modelNames = Array.from(modelNames);\n          }\n        } else {\n          ref = handleRefFunction(ref, doc);\n          modelNames = [ref];\n        }\n      } else if ((schemaForCurrentDoc = get(schema, 'options.refPath')) != null) {\n        isRefPath = true;\n        if (typeof refPath === 'function') {\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n\n          modelNames = new Set();\n          for (const subdoc of subdocsBeingPopulated) {\n            refPath = refPath.call(subdoc, subdoc, options.path);\n            modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n              forEach(name => modelNames.add(name));\n          }\n          modelNames = Array.from(modelNames);\n        } else {\n          modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n        }\n      }\n    }\n\n    if (!modelNames) {\n      // `Model.populate()` on a POJO with no known local model. Default to using the `Model`\n      if (options._localModel == null) {\n        modelNames = [model.modelName];\n      } else {\n        return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n      }\n    }\n\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n\n    return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _virtualPopulate(model, docs, options, _virtualRes) {\n  const map = [];\n  const available = {};\n  const virtual = _virtualRes.virtual;\n\n  for (const doc of docs) {\n    let modelNames = null;\n    const data = {};\n\n    // localField and foreignField\n    let localField;\n    const virtualPrefix = _virtualRes.nestedSchemaPath ?\n      _virtualRes.nestedSchemaPath + '.' : '';\n    if (typeof options.localField === 'string') {\n      localField = options.localField;\n    } else if (typeof virtual.options.localField === 'function') {\n      localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n    } else if (Array.isArray(virtual.options.localField)) {\n      localField = virtual.options.localField.map(field => virtualPrefix + field);\n    } else {\n      localField = virtualPrefix + virtual.options.localField;\n    }\n    data.count = virtual.options.count;\n\n    if (virtual.options.skip != null && !Object.hasOwn(options, 'skip')) {\n      options.skip = virtual.options.skip;\n    }\n    if (virtual.options.limit != null && !Object.hasOwn(options, 'limit')) {\n      options.limit = virtual.options.limit;\n    }\n    if (virtual.options.perDocumentLimit != null && !Object.hasOwn(options, 'perDocumentLimit')) {\n      options.perDocumentLimit = virtual.options.perDocumentLimit;\n    }\n    let foreignField = virtual.options.foreignField;\n\n    if (!localField || !foreignField) {\n      return new MongooseError(`Cannot populate virtual \\`${options.path}\\` on model \\`${model.modelName}\\`, because options \\`localField\\` and / or \\`foreignField\\` are missing`);\n    }\n\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc, doc);\n    }\n\n    data.isRefPath = false;\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    let justOne = null;\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    }\n\n    // Use the correct target doc/sub-doc for dynamic ref on nested schema. See gh-12363\n    if (_virtualRes.nestedSchemaPath && typeof virtual.options.ref === 'function') {\n      const subdocs = utils.getValue(_virtualRes.nestedSchemaPath, doc);\n      modelNames = Array.isArray(subdocs)\n        ? subdocs.flatMap(subdoc => virtual._getModelNamesForPopulate(subdoc))\n        : virtual._getModelNamesForPopulate(subdocs);\n    } else {\n      modelNames = virtual._getModelNamesForPopulate(doc);\n    }\n    if (virtual.options.refPath) {\n      justOne = !!virtual.options.justOne;\n      data.isRefPath = true;\n    } else if (virtual.options.ref) {\n      justOne = !!virtual.options.justOne;\n    }\n\n    data.isVirtual = true;\n    data.virtual = virtual;\n    data.justOne = justOne;\n\n    // `match`\n    const baseMatch = get(data, 'virtual.options.match', null) ||\n      get(data, 'virtual.options.options.match', null);\n    let match = get(options, 'match', null) || baseMatch;\n\n    let hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc, data.virtual);\n    }\n\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);\n        hasMatchFunction = true;\n      }\n\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n    data.localField = localField;\n    data.foreignField = foreignField;\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n\n    throwOn$where(match);\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, virtual);\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  return map;\n}\n\n/*!\n * ignore\n */\n\nfunction addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {\n  // `PopulateOptions#connection`: if the model is passed as a string, the\n  // connection matters because different connections have different models.\n  const connection = options.connection != null ? options.connection : model.db;\n\n  unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;\n  if (Array.isArray(unpopulatedValue)) {\n    unpopulatedValue = utils.cloneArrays(unpopulatedValue);\n  }\n\n  if (modelNames == null) {\n    return;\n  }\n\n  const flatModelNames = utils.array.flatten(modelNames);\n  let k = flatModelNames.length;\n  while (k--) {\n    let modelName = flatModelNames[k];\n    if (modelName == null) {\n      continue;\n    }\n\n    let Model;\n    if (options.model && options.model[modelSymbol]) {\n      Model = options.model;\n    } else if (modelName[modelSymbol]) {\n      Model = modelName;\n      modelName = Model.modelName;\n    } else {\n      try {\n        Model = _getModelFromConn(connection, modelName);\n      } catch (err) {\n        if (ret !== void 0) {\n          throw err;\n        }\n        Model = null;\n      }\n    }\n\n    let ids = ret;\n\n    const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;\n    if (data.isRefPath && Array.isArray(ret) && ret.length === modelNamesForRefPath.length) {\n      ids = matchIdsToRefPaths(ret, modelNamesForRefPath, modelName);\n    }\n\n    const perDocumentLimit = options.perDocumentLimit == null ?\n      get(options, 'options.perDocumentLimit', null) :\n      options.perDocumentLimit;\n\n    if (!available[modelName] || perDocumentLimit != null) {\n      const currentOptions = {\n        model: Model\n      };\n      if (data.isVirtual && get(data.virtual, 'options.options')) {\n        currentOptions.options = clone(data.virtual.options.options);\n      } else if (schemaOptions != null) {\n        currentOptions.options = Object.assign({}, schemaOptions);\n      }\n      utils.merge(currentOptions, options);\n\n      // Used internally for checking what model was used to populate this\n      // path.\n      options[populateModelSymbol] = Model;\n      currentOptions[populateModelSymbol] = Model;\n      available[modelName] = {\n        model: Model,\n        options: currentOptions,\n        match: data.hasMatchFunction ? [data.match] : data.match,\n        docs: [doc],\n        ids: [ids],\n        allIds: [ret],\n        unpopulatedValues: [unpopulatedValue],\n        localField: new Set([data.localField]),\n        foreignField: new Set([data.foreignField]),\n        justOne: data.justOne,\n        isVirtual: data.isVirtual,\n        virtual: data.virtual,\n        count: data.count,\n        [populateModelSymbol]: Model\n      };\n      map.push(available[modelName]);\n    } else {\n      available[modelName].localField.add(data.localField);\n      available[modelName].foreignField.add(data.foreignField);\n      available[modelName].docs.push(doc);\n      available[modelName].ids.push(ids);\n      available[modelName].allIds.push(ret);\n      available[modelName].unpopulatedValues.push(unpopulatedValue);\n      if (data.hasMatchFunction) {\n        available[modelName].match.push(data.match);\n      }\n    }\n  }\n}\n\nfunction _getModelFromConn(conn, modelName) {\n  /* If this connection has a parent from `useDb()`, bubble up to parent's models */\n  if (conn.models[modelName] == null && conn._parent != null) {\n    return _getModelFromConn(conn._parent, modelName);\n  }\n\n  return conn.model(modelName);\n}\n\nfunction matchIdsToRefPaths(ids, refPaths, refPathToFind) {\n  if (!Array.isArray(refPaths)) {\n    return refPaths === refPathToFind\n      ? Array.isArray(ids)\n        ? utils.array.flatten(ids)\n        : [ids]\n      : [];\n  }\n  if (Array.isArray(ids) && Array.isArray(refPaths)) {\n    return ids.flatMap((id, index) => matchIdsToRefPaths(id, refPaths[index], refPathToFind));\n  }\n  return [];\n}\n\n/*!\n * ignore\n */\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n  return ref;\n}\n\n/*!\n * ignore\n */\n\nfunction _getLocalFieldValues(doc, localField, model, options, virtual, schema) {\n  // Get Local fields\n  const localFieldPathType = model.schema._getPathType(localField);\n  const localFieldPath = localFieldPathType === 'real' ?\n    model.schema.path(localField) :\n    localFieldPathType.schema;\n  const localFieldGetters = localFieldPath && localFieldPath.getters ?\n    localFieldPath.getters : [];\n\n  localField = localFieldPath != null && localFieldPath.instance === 'Embedded' ? localField + '._id' : localField;\n\n  const _populateOptions = get(options, 'options', {});\n\n  const getters = 'getters' in _populateOptions ?\n    _populateOptions.getters :\n    get(virtual, 'options.getters', false);\n  if (localFieldGetters.length !== 0 && getters) {\n    const hydratedDoc = (doc.$__ != null) ? doc : model.hydrate(doc);\n    const localFieldValue = utils.getValue(localField, doc);\n    if (Array.isArray(localFieldValue)) {\n      const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);\n      return localFieldValue.map((localFieldArrVal, localFieldArrIndex) =>\n        localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n    } else {\n      return localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n    }\n  } else {\n    return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n  }\n}\n\n/**\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @param {Schema} schema\n * @return {Array|Document|Any}\n * @api private\n */\n\nfunction convertTo_id(val, schema) {\n  if (val != null && val.$__ != null) {\n    return val._doc._id;\n  }\n  if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {\n    return val._id;\n  }\n\n  if (Array.isArray(val)) {\n    const rawVal = val.__array != null ? val.__array : val;\n    for (let i = 0; i < rawVal.length; ++i) {\n      if (rawVal[i] != null && rawVal[i].$__ != null) {\n        rawVal[i] = rawVal[i]._doc._id;\n      }\n    }\n    if (utils.isMongooseArray(val) && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (getConstructorName(val) === 'Object' &&\n      // The intent here is we should only flatten the object if we expect\n      // to get a Map in the end. Avoid doing this for mixed types.\n      (schema == null || schema[schemaMixedSymbol] == null)) {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map')`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n\n  return val;\n}\n\n/*!\n * ignore\n */\n\nfunction _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {\n  // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n  // out embedded discriminator docs that don't have a `refPath` on the\n  // populated path.\n  if (!data.isRefPath || normalizedRefPath == null) {\n    return;\n  }\n\n  const pieces = normalizedRefPath.split('.');\n  let cur = '';\n  let modelNames = void 0;\n  for (let i = 0; i < pieces.length; ++i) {\n    const piece = pieces[i];\n    cur = cur + (cur.length === 0 ? '' : '.') + piece;\n    const schematype = modelSchema.path(cur);\n    if (schematype != null &&\n        schematype.$isMongooseDocumentArray &&\n        schematype.Constructor.discriminators != null &&\n        Object.keys(schematype.Constructor.discriminators).length !== 0) {\n      const subdocs = utils.getValue(cur, doc);\n      const remnant = options.path.substring(cur.length + 1);\n      const discriminatorKey = schematype.Constructor.schema.options.discriminatorKey;\n      modelNames = [];\n      for (const subdoc of subdocs) {\n        const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n        const discriminator = schematype.Constructor.discriminators[discriminatorName];\n        const discriminatorSchema = discriminator && discriminator.schema;\n        if (discriminatorSchema == null) {\n          continue;\n        }\n        const _path = discriminatorSchema.path(remnant);\n        if (_path == null || _path.options.refPath == null) {\n          const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);\n          ret.forEach((v, i) => {\n            if (v === docValue) {\n              ret[i] = SkipPopulateValue(v);\n            }\n          });\n          continue;\n        }\n        const modelName = utils.getValue(pieces.slice(i + 1).join('.'), subdoc);\n        modelNames.push(modelName);\n      }\n    }\n  }\n\n  return modelNames;\n}\n\n/**\n * Throw an error if there are any $where keys\n */\n\nfunction throwOn$where(match) {\n  if (match == null) {\n    return;\n  }\n  if (typeof match !== 'object') {\n    return;\n  }\n  for (const key of Object.keys(match)) {\n    if (key === '$where') {\n      throw new MongooseError('Cannot use $where filter with populate() match');\n    }\n    if (match[key] != null && typeof match[key] === 'object') {\n      throwOn$where(match[key]);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}